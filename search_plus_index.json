{"./":{"url":"./","title":"Vue 教程","keywords":"","body":"前言前后端分离关于 Vue关于本教程如何食用License前言 前后端分离 前后端分离是目前常用的网站开发模式。下面用一个例子介绍一下前后端各自负责的任务。 假设现在访问教务系统，浏览器展示登录界面，我们输入学号和密码，点击登录，账号密码正确即可进入。这个过程都经历了什么呢？ 首先，初始访问时，网页端会查询本地浏览器是否存有登录信息缓存，如果在不久前登录过，会记录用户信息，则这次访问将直接展示网页内容，无需登录。如果查无登录信息，或登录信息过期失效，则网页端跳转登录路由，显示登录界面。输入学号密码，点击登录按钮，此时网页端会向服务器发送登录请求，由服务器端查询数据库，验证账号密码是否正确，将结果返回网页端。网页端收到正确信号后，跳转至教务系统网页，收到错误信号则提示账号或密码错误。 上面这个访问的例子是从前后端的角度解释的，因此未提及DNS解析等其它的内容。在上面的描述中，网页端和服务器端可以理解为前端和后端，不难看出它们各自负责的任务： 前端：与浏览器联系，负责渲染页面内容，跳转路由，存取浏览器缓存，与后端（服务器端）交互 后端：负责存取数据库信息，处理复杂数据，响应前端的请求 关于 Vue 了解了前后端，再来说一说本教程讲的 Vue。 Vue 是编写前端项目的一个框架，官网的介绍如下： Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 初学者不用刻意理解这个官方解释，只需要知道，我们将借助 Vue CLI 脚手架来搭建 Vue 项目框架，从而编写前端项目，完成在前面所讲述的前端任务。 关于本教程 在本教程中，你能学到或不能学到： Skill Able/Unable Vue 框架的基本介绍 ✅ Vue 开发的基础能力 ✅ 可以用来点睛的前端技巧 ✅ 最基础的 HTML/CSS/JS 代码 ❌ 与其它网上教程不同的是，本作品尽可能手把手演示项目的创建和基本介绍，达到快速入门的效果。同时，在开发中我所用到的一些奇巧的插件或技巧，都会在这里记录。 [!TIP|style:flat] 为方便学习者或开发者熟悉代码的功能，本人改写已有项目和自己编写后端，实现了简易的 Vue 在线运行、预览的在线平台，同时具有类似 ubuntu pastebin 发布分享代码的功能，将在教程中结合使用，学习者也可自行尝试编写代码查看效果。源码仓库地址：ZewanHuang/vue-online 如何食用 两种方式： 希望快速入门或有一定的前端基础：安装好环境，理解项目架构后，直接跟着教程的开发实战上手，在完善登录页面中快速入门； 希望系统学习、了解更多基础知识：从头到尾，按照教程各篇文章的提示系统学习。 License 本作品采用 CC BY-NC-SA 4.0 进行许可。 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part0/01-install_vue.html":{"url":"post/part0/01-install_vue.html","title":"Vue 安装","keywords":"","body":"Vue 安装下载 NVMNVM 常用命令使用 Nvm 安装 Nodejs安装 Vue 环境后言1. 安装 Vue 的其它方式2. 关于 Nvm 的实现方式3. Npm 安装包速度慢的问题Vue 安装 使用 Vue.js 的方式有很多，包括直接用 script 标签引入、使用 CDN 方法引入、NPM 方法安装等。在一般较大的项目开发中，都会采取后者，这里也仅对 NPM 安装方式进行介绍。 NPM 是 Nodejs 下的包管理器，具备命令行接口和软件注册中心 (registry)，使用 npm 可以安装、管理、运行 packages，为项目代码适配 packages 等。本教程常用的是用它来安装环境包（如 vue-cli），以及运行 vue 等前端项目（npm run serve）。 下载 NPM，有两种方法，直接下载使用一个特定版本，或安装 NVM（npm version manager）可管理多个 NPM 版本环境。我推荐的是使用 NVM 安装。原因是 Nodejs 版本更新快，向前兼容性较差，很容易平时使用的版本无法安装某个插件环境。比如 v14 安装了 vue 环境，此时想在本地安装 gitbook 环境，发现很多插件要求 v10，如果采用的单一版本就无法使用这些插件。而 nvm 就是类似 conda 的环境管理器，允许在一台机器拥有多个 NPM 版本环境。 不想采用 NVM 安装方法，文末有推荐直接安装 NPM 的博客链接 下载 NVM 若本地有 Nodejs 环境，下载 NVM 前需先卸载！ 第一步，下载最新版 nvm，链接如下： Windows 版本：https://github.com/coreybutler/nvm-windows/releases，下载 nvm-setup.zip Mac 版本：https://github.com/nvm-sh/nvm#install--update-script 下载时注意安装路径不能出现空格，最好不要用中文路径！ 安装完成后，输入下列命令验证是否安装成功： nvm --version 接下来，将 npm 包的下载源地址更改为淘宝镜像。打开 nvm 安装文件夹，在文件夹下的 settings.txt 文件中添加： node_mirror: http://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ NVM 常用命令 给出一些常用的 nvm 命令： nvm --version # 查看nvm版本 nvm install latest # 安装最新版 nodejs nvm install # 安装指定版本 For examle: nvm install v14.16.0 nvm ls # 查看已安装的 nodejs 版本 nvm use v14.16.0 # 切换使用 v10.13.0 版本 nvm alias default 14.16.0 # 设置默认版本 使用 Nvm 安装 Nodejs 使用 nvm install 命令安装 Nodejs，这里以 14.16.0 版本为例： nvm install v14.16.0 等待较短时间后，即安装成功。 接下来输入： nvm use v14.16.0 npm --version 可确认 npm 是否安装成功。 [!TIP|style:flat] 执行 nvm use 命令后若出现 return status 1 和一段乱码的错误提示，则用管理员身份打开 cmd 重新执行 安装 Vue 环境 输入以下命令，安装 vue.js、vue-router、vue-cli 脚手架到 global 全局目录： npm install vue -g npm install vue-router -g npm install -g @vue/cli 使用 vue-cli 创建 vue 项目： vue create my-project # 这里需要进行一些配置，可选择 vue2 或 vue3，后面文章再提 进入项目，安装并运行： cd my-project npm install npm run serve 成功运行后，访问 http://localhost:8080/ 即可看到 vue 项目的默认界面。 如果 8080 端口被占用，这里的端口可能会改变，实际以终端提示为主 后言 1. 安装 Vue 的其它方式 如果不想采用本文章所讲的『Nvm管理和Npm安装』的方式，可以参考以下链接直接安装 NPM： 安装Node.js和npm - 廖雪峰的官方网站 Vue.js 安装 - 菜鸟教程 2. 关于 Nvm 的实现方式 如果安装了多个 Nodejs 版本，可以看到 nvm 目录下有多个版本对应的目录，比如 v10.13.0、v14.16.0 等；安装时选择了两次路径，第二次设置的是当前使用的 Nodejs 环境，可以看到安装后它是一个快捷方式，指向 nvm 目录下的某个版本。 3. Npm 安装包速度慢的问题 不管是使用 Nvm 管理还是直接下载 Npm，都可能会遇到 Npm 安装依赖速度慢的问题，原因是 Npm 官方镜像服务器在海外，当然如果你有科学上网的工具，应该没这个问题。国内加速访问可以通过以下命令指定 Npm 安装镜像为淘宝镜像： npm config set registry https://registry.npm.taobao.org Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part0/02-project_init.html":{"url":"post/part0/02-project_init.html","title":"Vue 项目创建","keywords":"","body":"Vue 项目创建终端命令WebStorm创建Vue 项目创建 Vue 项目的创建方式，与习惯使用的编辑器有一定的关系。我一般使用 WebStorm 进行前端开发，因此常用它来创建 Vue 项目；而使用 VS Code 的一般会用终端命令来创建。下面对两种方式都介绍一下。 终端命令 使用 Vue CLI 创建 vue 项目： vue create vue-project # [vue-project] 为项目名称 选择项目模式，本教程将首先介绍 Vue2 的使用，因此在这里选择第一项。这里的 router 表示路由管理，vuex 表示前端状态存储管理，后续的开发会使用到，因此选择该项。 等待片刻后，初始化项目成功。 输入图中终端提示的命令，进入目录： cd vue-project 本地运行项目： npm run serve 如需打包部署到服务器上，则输入： 关于 build 命令在部署时需要使用，后面文章可能会讲到 npm run build WebStorm创建 打开 WebStorm，点击 File -> New Project，选择 Vue.js，设置路径和 Node 解释器、Vue CLI（一般会自动识别）后，点击 Create。在这里，我一般会勾选掉 Use default project setup，以便在后续选择配置。 和终端方式类似，创建后会提示选择： 选择第一项，回车。等待片刻后，创建成功，WebStorm 界面如下： 点击右上角的“开始”按钮，就可运行项目。 我们可以配置同样的方式来打包项目以便部署。点击右上角“开始”按钮旁的下拉框，选择 Edit Configurations，如下图配置： 点击OK后，可以在右上角看到build的字样。在下拉框可以选择serve或build，后点击“开始”按钮即可运行或打包。 使用哪种方式创建项目都可以，当然也可以终端命令创建后用 WebStorm 打开，全看个人开发习惯。我个人更喜欢 Jetbrains 软件的界面，因此习惯使用 WebStorm 开发前端。 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part1/01-vue2-structure.html":{"url":"post/part1/01-vue2-structure.html","title":"Vue 项目初识","keywords":"","body":"Vue 项目初识node_modulespublicsrcassetscomponentsrouterstoreviewsApp.vuemain.jsVue 项目初识 上篇文章创建了一个初始的 Vue2 项目，本文对这个几乎空白的项目框架进行简要介绍。 [!TIP|style:flat] 阅读本文时并不要求理解各部分是如何编写的，只大致了解它们的用途，在下一篇文章将用一个实例来展示如何使用。 目录/文件 说明 node_modules npm 加载的项目依赖模块 public 静态资源，build 构建后为根目录，含网站导航栏图标、首页入口文件 src 开发做的事情基本都在这个目录下，含： • assets: 放置一些图片、字体等资源  • components: 放置组件文件，一般为全局组件 • router: 网站路由跳转设置 • store: 前端数据存储 • views: 放置各页面文件 • App.vue: 项目入口文件 • main.js: 项目的核心文件，在这里可以导入各种全局依赖 .xxx文件 配置文件，包括语法配置、git配置(.gitignore)等 package.json 项目配置文件 README.md 项目的说明文档 下面对主要模块进行讲解。 node_modules node_modules 目录下放置项目所需要的依赖环境，当使用 npm install packageName --save 命令给项目添加依赖时，信息会记录于 package.json 文件的 dependencies 中，而依赖的包将存储于 node_modules。 在该目录下，可以发现有我们在创建项目时选择的 vue-router 包，这是用于管理路由跳转的依赖。 在编辑器中可以看到该目录名字显示灰色的，因为它在 .gitignore 是被忽略的。在合作开发项目中，往往使用 git 来协调配合，而该目录内容庞大，且并非由程序员编写，因此往往不加入 git 中，在新机器上使用 npm install，则会根据 package.json 的配置信息生成 node_modules。 public 初始项目中，public 目录下有 favicon.ico 和 index.html 两个文件，前者是网站图标logo，后者是网站首页入口文件，代码如下： favicon.ico\"> We're sorry but doesn't work properly without JavaScript enabled. Please enable it to continue. 上述代码包含了一个网页最基本的信息，在 head 标签中，我们可以编写网站的标题title、编码charset、图标icon、描述description、关键词keywords等信息；在 body 标签中，vue 项目通常只需要包含 ，表示 App.vue 文件。 src assets assets 目录放置项目所需要的资源，如图片、字体等，并由 vue 文件使用。 components components 目录放置项目的全局组件。 在项目开发中，存在部分小模块需要多次复用，比如导航栏、某些样式的按钮等，通常被提取出来作为全局组件。与之对应的是局部组件，通常是某个页面内容较多，使用多个 vue 文件编写，其中某个 vue 文件和其它文件为父子关系，父引入子，实现低耦合的特性。 初始项目中，该目录下有 HelloWorld.vue 文件，可以看到在 views/Home.vue 中，引入了该文件。 在这里也简略说明一下 vue 文件的组成。vue 文件主要由三部分组成： template：html，网页结构内容 script：该vue文件所需的数据对象格式、js方法等 style：css页面样式 router router/index.js 编写路由规则，即赋予 vue 文件相应的相对路由，核心代码为： const routes = [ { path: '/', name: 'Home', component: Home }, { path: '/about', name: 'About', component: () => import('../views/About.vue') } ] 其中，path 为分配的相对路由，component 指定 vue 视图页面。 初始项目运行在 localhost:8080 时，访问 localhost:8080/about 将显示 About.vue 的内容。 store store 目录下主要放置前端存储数据的格式，利用 vuex 和 localStorage 在用户的网页端保存基本的用户信息。例如用户登录之后，将用户名存于前端，这样在渲染网页时可以直接使用，且向后端发送请求时可以携带用户名，以验证用户的登录信息是否有效。 views 在 views 目录下，主要是页面或局部组件的 vue 文件。看初始项目，里面有 About.vue 和 Home.vue，分别对应路由 /about 和 /。简单看一下这两个文件： About.vue：内容很简单，仅包含 html 部分，仅仅是一句话。 This is an about page Home.vue：包含 html 和 script 两部分，可以看到在 script 标签中引入了 HelloWorld 组件，然后在 html 部分中进行调用，这样该页面的效果为，logo 图片加 HelloWorld 组件。 // @ is an alias to /src import HelloWorld from '@/components/HelloWorld.vue' export default { name: 'Home', components: { HelloWorld } } App.vue App.vue 为项目入口文件，该文件描述整个网站将渲染的内容。 Home | About 如上述代码，它由 nav 的代码块和 router-view 组成。前者是两个超链接，有点类似于网站的导航栏，将在各路由下都展示；后者表示根据路由渲染对应的 vue 组件，如果当前是 /about 则渲染 About.vue 文件描述的内容。 main.js main.js 是项目的核心文件，在这里可以导入各种全局依赖。比如全局导入 elementUI 等UI组件或 ECharts 可视化图标库等，npm install 后将在该文件中全局引入。 以上介绍了 vue2 项目创建初始的各模块用途，掺杂了部分代码编写的指示，并不要求完全理解。在下一篇文章中，将会在初始项目的基础上编写一个登录页面，以帮助初学者更快入门。 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part1/02-instance.html":{"url":"post/part1/02-instance.html","title":"Vue 开发实战一：登录页面","keywords":"","body":"Vue 开发实战一：登录页面添加网站基本信息编写登录页面添加路由美化登录页面后言Vue 开发实战一：登录页面 本文将在初始化项目的基础上，编写一个登录页面，并为其设定路由和存储登录信息等。在阅读本文时，建议跟着敲敲代码，以加深对 vue 项目的理解。当然，如果觉得现在就开始写代码有点快，难以理解，也可以先看看后面文章再回来看本文。在这里就开始写代码，主要是为了给初学者提供一个快速入门的途径。 本文代码的仓库：https://github.com/Super-BUAA-2021/vue-template 不熟悉 git 的同学可以看看仓库的 commit 提交记录，理解 commit 的时机 添加网站基本信息 首先修改 public/index.html 的内容，在里面添加上本网站的基本信息，如keywords、description等，以及修改网站标题。 Vue Template 注意到，在 body 标签中添加了 style=\"margin:0; padding:0;\"，作用是使网页整体无边界。如果没加上，开发中会发现网站外围有一道较为明显的白色边框。 编写登录页面 在 views 目录下新建 Login.vue 文件，用 WebStorm 新建 vue 文件时，会自动生成如下代码框架： export default { name: \"Login\" } template 标签内：编写 html 内容，即网页的基本结构 script 标签内：编写数据对象格式、方法等 style 标签内：编写 css 样式，对应 template 内的内容 在实践中可以更好地理解这三部分，所以先来试着编写登录页面的基本内容，代码如下： Login Login export default { name: \"Login\", data() { return { username: '', password: '' } }, methods: { click_login() { window.alert(this.username + this.password); } } } 如上述代码， template 标签：定义了一个表单 form，内部展示 Login 的字样，同时有两个 input 供输入和一个 button 作登录按钮； script 标签： 添加 data，定义数据对象 username 和 password，分别绑定表单中的两个 input 添加 methods，定义方法 click_login，与按钮绑定，当用户点击按钮时，浏览器将弹窗展示 username 和 password 的值 添加路由 在编写完上面登录页面的基本内容后，还无法看到该网页长啥样，需要在 router/index.js 中添加该页面的路由，才能访问到。 只需为 routes 数组添加元素，指明 path、name 等信息： const routes = [ { path: '/', name: 'Home', component: Home }, { path: '/login', name: 'Login', component: () => import('../views/Login') } ] 这样，npm run serve 运行项目后，访问 localhost:8080/login，可以看到编写的页面： 还没写 CSS 样式，是最原生的样貌 美化登录页面 一个好的前端，一定要拿捏 CSS。当然，它不是那么好拿捏的，因为涉及的内容太多了。（水太深）接下来，就试着美化一下。 在前面编写 template 部分时，已为各元素创建了 class 属性，接下来在 style 部分中为相应的 class 编写特定的 CSS样式。 首先，设置表单样式： .form-box { width: 300px; padding: 40px; /* 内边界宽度 */ position: absolute; /* 设置为绝对定位，使下方的top和left生效 */ top: 50%; left: 50%; transform: translate(-50%,-50%); /* 作用见后方描述 */ background: #90b9e5; /* 设置背景颜色 */ text-align: center; /* 表单中内容居中 */ border-radius: 10px; } transform: translate(-50%,-50%); 作用的讲解：当使用top: 50%; left: 50%; 时，是以整个表单的左上角为原点，所以表单不处于中心位置，会偏右下一点。而 translate(-50%,-50%) 作用是，往上（x轴）、左（y轴）移动自身长宽的 50%，这样表单就刚好位于正中间。 因此上述代码的 position~transform 是使表单在页面中央。 接着将 Login 字样全部大写： 其实直接在 template 标签内把 login 大写也可 .form-box h1 { text-transform: uppercase; /* 将字体全部设置成大写字母 */ } 设置用户名输入框和密码输入框的样式： .form-box .username, .form-box .password { border-radius: 24px; /* 边框四个角的弧度 */ border: 2px solid #3498db; /* 边框厚度和颜色 */ background: none; display: block; margin: 20px auto; /* 外边界 */ text-align: center; padding: 14px 10px; /* 内边界 */ width: 200px; outline: none; color: white; /* 设置输入框中竖线的颜色 */ transition: 0.25s; /* 设置元素过渡效果 */ } 设置文本框获得焦点时的样式，即用户点击时输入框的样式，focus设置的样式会在原样式基础上进行覆盖修改： .form-box .username:focus,.form-box .password:focus{ border-color: #2ecc71; /* 边框颜色 */ } 设置提交按钮的样式： .form-box .login{ border-radius: 24px; border: 2px solid #0b95f1; background: none; display: block; margin: 20px auto; padding: 14px 40px; outline: none; transition: 0.25s; cursor: pointer; /* 设置光标的样式 */ } 刷新网站，可以发现登录页面终于有点拿得出手了。 查看效果 后言 我认为前端的主要任务有两个： 编写和美化页面 编写函数方法，包括响应用户的交互事件和请求后端的服务 本文的实战中，只是介绍了第一个任务，未涉及 JavaScript 函数方法的编写，仅用了一个弹框来相应点击登录事件，因此目前还只是空壳一个。 用户输入用户名和密码，点击 Login 按钮，网页获取到点击事件后，调用函数进行处理，也就是本文代码中还未填充的坑 click_login。这个函数需要做的事情通常包含： 验证用户输入的 username 和 password 是否符合规范 将这两个字段发送给后端 获取到后端的响应信息，根据不同的信号进行不同的处理 用户名不存在或密码错误，则提示用户 密码正确，则登录成功，保存用户信息，跳转主页 因为这部分涉及 axios 的使用，后面的文章先对本次实战消化讲解一下，再来填上这个坑。 另外，本文的页面编写没有使用elementUI等UI组件库，而实际开发中使用这些组件库能达到事半功倍的效果，因为它帮我们写好了很多东西，比如样式之类的。在后面讲到UI组件库使用时，会改写登录页面。 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part1/03-grammar.html":{"url":"post/part1/03-grammar.html","title":"Vue 语法语句","keywords":"","body":"Vue 语法语句数据绑定插值用户输入过滤器事件绑定点击按钮事件条件语句循环语句遍历数组遍历对象Vue 语法语句 上篇文章带着编写了基本的登录页面，让初学者对 Vue 项目开发有一定的了解，但没有细致讲解 Vue 的语法、路由等，因此接下来的文章将对这些知识点展开介绍。内容较多，建议快速阅览，留个印象，在实际开发中熟悉。 数据绑定 Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。 不太准确地说，当用户输入或其它途径修改了 “template” 中的数据元素时，“script” 内的 Vue 底层数据也会更新；当某些 JS 方法修改了数据时，也会将更新后的数据同步渲染 DOM。 插值 文本插值 数据绑定最常见的形式是使用 {{...}} 双大括号： {{ msg }} export default { data() { return { msg: '北航软院yyds' } }, } 查看效果 v-html 使用 v-html 指令渲染 html 内容： export default { data() { return { msg: '北航软院yyds' } }, } 查看效果 属性 HTML 属性中的值使用 v-bind 指令进行绑定。以下实例判断 isShow 的值，为 true 时使用 class1 的样式，否则不使用： GOOD export default { data() { return { isShow: true } }, } .class1 { color: red; } 查看效果 用户输入 在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定： export default { data() { return { msg: '北航软院yyds' } }, } 查看效果 v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。 过滤器 Vue.js 允许自定义过滤器，用于格式化文本数据并渲染。以下实例将字符串首字母转为大写： {{ msg | capitalize }} export default { data() { return { msg: 'beihang is good!' } }, filters: { capitalize(value) { if (!value) return ''; value = value.toString(); return value.charAt(0).toUpperCase() + value.slice(1); } } } 事件绑定 Vue 主要使用 v-on 监听事件，调用相应函数对用户的交互做出响应。 点击按钮事件 按钮事件为 click，v-on:click=\"event\" 表示当用户点击时调用 event 方法。以下实例在用户点击按钮后改变字符串： {{ msg }} 切换 export default { data() { return { msg: '北航软院yyds', msg1: '北航软院yyds', msg2: '啊对对对' } }, methods: { change() { this.msg = (this.msg == this.msg1)? this.msg2: this.msg1; } } } 查看效果 在开发中可能会看到 v-on:click 和 @click 两种用法，实际上这两种是一样的，后者是前者的缩写。 条件语句 条件判断使用 v-if、v-else-if、v-else 指令，以下实例通过判断 flag 的值展示不同的内容。 {{ msg1 }} {{ msg2 }} {{ msg3 }} export default { data() { return { msg1: '北航软院yyds', msg2: '啊对对对', msg3: 'ABC', flag: '1', } } } 查看效果 循环语句 遍历数组 使用 v-for 指令绑定数据到数组来渲染一个列表： {{ tea.name }} export default { data() { return { teachers: [ { name: 'ZewanHuang' }, { name: 'Matrix53' } ] } } } 查看效果 遍历对象 {{ value }} export default { data() { return { obj: { name: 'Vuebook', url: 'https://super-buaa-2021.github.io/Vuebook/', slogan: '前端的水太深，你要好好把握！' } } } } 查看效果 [!TIP|style:flat] 本文介绍的语法语句在 Vue 项目开发中经常使用，建议自己动手熟练熟练。最快速上手的方法还是直接在开发中熟悉，记不清了就回来查一查。 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part1/04-attribute.html":{"url":"post/part1/04-attribute.html","title":"Vue 生命周期与属性","keywords":"","body":"Vue 生命周期与属性createdmountedmethodscomputedwatchVue 生命周期与属性 在开发中，常涉及的 Vue 生命周期含 created 和 mounted，常用的属性含方法属性 methods、计算属性 computed、监听属性 watch 等，因此本文仅介绍上述五个知识，完整的 Vue 生命周期可以参考该博客进行学习。 created Vue 生命周期中的 created 是指 template 渲染成 html 前的阶段。在该阶段中，通常需要初始化某些数据值，比如向后端发送请求以获取页面信息，然后再渲染视图。 示例：进入用户设置页面，需要请求后端，获取用户名、邮箱等基础信息。 {{ username }} {{ email }} export default { data() { return { username: '', email: '', } }, created() { // 使用 axios 向后端发送请求，后续文章将介绍到，此处仅表示该意思 this.$axios.post(...) // 将返回值赋值给数据 this.username = res.data.username; this.email = res.data.email; } } mounted mounted 是在 template 渲染成 html 后的阶段。在该阶段中，也就是初始化页面完成后，通常对 html 的某些 DOM 节点进行一些操作，比如绘制图表渲染到某个节点上。这些操作由于涉及 DOM 节点，不能在 created 阶段中完成，因为该阶段还未渲染出相关节点。 HTML DOM 将 HTML 当作由各标签组成的树结构，DOM 节点可视为各标签渲染出来的结构节点 相比 created，mounted 较为少用，该阶段的操作常需要用下面命令获取 id 为 xxx 的 DOM 节点，再将图表渲染到该节点。 var x = document.getElementById(\"xxx\"); methods 在 Vue 的 methods 属性中，常定义事件处理方法，用于绑定和处理点击、回车事件等，当然，也可以将方法作为插值直接渲染。 示例：使用 login 函数处理点击按钮事件。 登录 export default { data() { return { msg: \"\" } }, methods: { login: function() { if (this.msg !== '') alert(\"登录成功！\"); else alert(\"登录失败！\"); } } } 查看效果 computed 在 Vue 中，可以定义计算属性对数据进行处理，并返回处理结果。 下面的例子定义了 rmsg 属性，计算 msg 的反转字符串： {{ msg }} {{ rmsg }} {{ rmsg_by_method() }} export default { data() { return { msg: \"软件学院\" } }, computed: { rmsg: function() { return this.msg.split('').reverse().join(''); } }, methods: { rmsg_by_method: function() { return this.msg.split('').reverse().join(''); } } } 查看效果 在上面的示例中，还定义了一个方法，实现了与计算属性一致的效果。那 computed 与 methods 的区别是什么？ [!NOTE|style:flat] computed 是基于依赖缓存的，只有相关依赖发生改变时才会重新计算值；而使用 methods，在重新渲染或再次调用的时候，函数总会重新调用执行，可以理解一下菜鸟教程中的示例。在没有使用依赖缓存时，推荐使用 methods，它能接受参数，使用更灵活。 目前我们只介绍了计算属性的 getter，即获取值，在需要时可以定义该属性的 setter。 下面例子为 site 属性定义了 setter，当为该属性赋值时，将调用定义的 setter。 {{ site }} {{ name }} {{ url }} export default { created() { this.site = \"ZewanHuang blog.zewan.cc\"; }, data() { return { name: '', url: '', } }, computed: { site: { // getter get: function () { return this.name + ' ' + this.url }, // setter set: function (newValue) { var names = newValue.split(' ') this.name = names[0] this.url = names[names.length - 1] } } }, } 查看效果 watch Vue 的监听属性 watch，可以用来监听数据、响应数据的变化。 示例一：利用 watch 实现计数器。 计数器：{{ counter }} 加一 export default { data() { return { counter: 1 } }, watch: { counter(newVal, oldVal) { alert(\"计数器：\" + oldVal + \"变为\" + newVal); } } } 查看效果 示例二：实现千米和米之间的换算。 千米： 米： export default { data() { return { kilometer: '', meter: '' } }, watch: { kilometer(newVal) { this.meter = newVal*1000; }, meter(newVal) { this.kilometer = newVal/1000; } } } 查看效果 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part1/05-router.html":{"url":"post/part1/05-router.html","title":"Vue 路由","keywords":"","body":"Vue 路由vue-router库路由定义$router 路由跳转 路由跳转路由钩子(导航守卫)Vue 路由 在 Vue 开发实战一中，使用了简单的路由定义，给登录页面设定了路由 /login，本篇文章将介绍路由的定义、跳转和更深入的路由钩子(导航守卫)。 vue-router库 Vue.js 路由需要载入 vue-router库。 在创建项目初始，若已选中使用 router，则已自动载入；否则需安装引入： npm install vue-router --save 路由定义 常在 router/index.js 中定义网站的路由： /* 0. 导入 Vue 和 VueRouter，调用 VueRouter，需要时可导入主要的 Vue 组件 */ import Vue from 'vue' import VueRouter from 'vue-router' import Home from '../views/Home.vue' Vue.use(VueRouter) /* 1. 定义路由，每个路由对应一个 Vue 组件 */ const routes = [ { path: '/', name: 'Home', component: Home }, /* path 指定路由，name 设定路由标志名，component 指定 Vue 组件，可使用 import 导入 */ { path: '/about', name: 'About', component: () => import('../views/About.vue') }, { path: '/login', name: 'Login', component: () => import('../views/Login') } ] /* 2. 创建 router 实例，配置参数等 */ const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, routes }) /* 3. 导出 router，在 main.js 中挂载到根实例 */ export default router 在创建项目时，该文件的大致框架已自动建立，编写新页面时只需照葫芦画瓢，在 routes 数组中添加元素指定路由即可。 path：指定路由 name：指定路由标志名，可在跳转命令中用以代替path component：指定路由对应的 Vue 组件，常使用 import 引入 $router 路由跳转 在 Vue 实例内部，可以在 JavaScript 中通过 $router 访问路由实例，因此可以调用 this.$router.push 或 this.$router.replace 实现编程式路由跳转。 push 方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如： // 字符串，指跳转至 /home this.$router.push('home') // 对象，指跳转至 /home this.$router.push({ path: 'home' }) // 命名的路由，使用 name 代替 path 的指定作用，同时传递 userId 参数 this.$router.push({ name: 'user', params: { userId: '123' } }) // 带查询参数，跳转后路由为 /register?mode=vip this.$router.push({ path: 'register', query: { mode: 'vip' } }) // params 和 query 方法的区别在于，后者会将参数显式地展示在目的路由中 注意： 使用 params 传参，对象属性里只能是 name 而不能是 path，即 params 方法只能使用 name 引入路由； 如果目的路由和当前路由相同，只有参数发生了改变，比如从一个用户资料 /user/1 跳转到另一个用户 /user/2，则可能需要使用 Vue.js 生命周期的 beforeRouteUpdate 来响应这个变化，比如重新获取用户信息。 [!TIP|style:flat] 路由跳转后，常需要接收参数，query 方式使用 this.$route.query.mode 接收 mode 参数，params 方式使用 this.$route.params.userId 接收 userId 参数。 router.replace 用法与 push 一样，两者区别在于它不会向 history 添加新纪录，而是将新路由替换掉当前的 history 记录，因此无法通过前进后退进行跳转。 router.go 也能实现路由跳转，只不过是在 history 记录中向前或后退多少步，例如： // 在浏览器记录中前进一步，等同于 history.forward() router.go(1) // 后退一步记录，等同于 history.back() router.go(-1) // 前进 3 步记录 router.go(3) // 如果 history 记录不够用，就默默地失败 router.go(-100) router.go(100) 路由跳转 除了在 JS 方法中实现路由跳转，在 HTML 部分也可以使用 标签直接渲染，获取到点击事件则跳转。 该标签含有 to 和 replace 属性，前者对应 router.push，后者对应 router.replace。例如： Home Home Home User Register 更多 router-link 的用法见 Vue.js 路由 - RUNOOB 事实上， 标签可以使用 @click + router.push 代替，即在 html 的内容中添加 @click 属性调用函数，在函数中使用 router.push 实现跳转。 路由钩子(导航守卫) 一个完整的网站，可能需要对不同身份的用户进行路由访问的拦截，比如未登录用户无法访问用户中心，非管理员用户无法访问管理中心，当进行“违法”访问时可以设置自动跳转至登录页面。上述功能的实现，可以使用路由钩子。 示例：未登录用户访问用户中心（需要登录后才允许访问的页面），拦截至登录页面。 在 router/index.js 中，对需要登录才可访问的路由设置 meta 属性信息： const routes = [ { path: 'center', name: 'Center', component: () => import('../views/center.vue'), meta: { requireAuth: true } } ] 继续在该文件中添加以下代码，判断未登录则跳转登录页面： import user from \"@/store/user\"; router.beforeEach((to, from, next) => { // 通过 Vuex 获取用户登录信息（在实战篇中会介绍到） const userInfo = user.getters.getUser(user.state()) // 若用户未登录且访问的页面需要登录，则跳转至登录页面 if (!userInfo && to.meta.requireAuth) { next({ name: 'Login', }) } next() }) 这样就完成了简单的导航守卫，更多实用的将在实战中使用和讲解。 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part1/06-axios.html":{"url":"post/part1/06-axios.html","title":"Vue axios 请求","keywords":"","body":"Vue axios 请求安装 Axios全局引入发送请求并发请求Vue axios 请求 Vue.js 2.0 版本推荐使用 axios 来完成对后端的请求。 Axios 是一个基于 promise 的网络请求库(HTTP)，可以用于浏览器和 node.js 中。 安装 Axios npm install axios --save 全局引入 网站开发中，向后端发送请求的使用次数高，因此全局引入将方便在各组件中随处使用。 全局引入只需在 main.js 文件中添加以下内容： import axios from 'axios' /* 引入 axios 并挂载到 Vue 实例上 */ Vue.prototype.$axios = axios /* 指定 axios 发送请求的目标后端地址的根路径，一般为后端服务器IP+端口，若有部署域名则可以是域名地址 */ axios.defaults.baseURL = 'http://123.12.123.12:8000'; 全局挂载后，不需要在各组件重复引入。如上述方式全局引入后，在各组件使用 this.$axios 就可以使用 axios 的功能。 在 main.js 中指定后端地址根路径，这样在各 vue 组件中向后端发送请求时，就不需要重复写明根路径。且当运行或部署的服务器(包括从本地要部署到服务器上)发生变化时，只需要修改此处的根路径即可。 关于后端如何运行部署的，前端开发人员不需要了解。等收到后端人员给的根路径和各 api 的路由地址，只管向这些 api 发送请求了。 发送请求 前端向后端发送请求，常用的两种请求方式为 POST 和 GET。 [!NOTE|style:flat] GET 和 POST 是 HTTP 协议中发送请求的方法。GET 方法请求一个指定资源的表示形式，应该只被用于获取数据；POST 方法用于提交实体到指定的资源，通常导致在服务器上的状态变化，比如涉及对数据库的写入。更详细的区别可见『面试官：说一下 GET 和 POST 的区别？』。 axios 请求的 POST 和 GET 两种方式可以有不同的编写，分别是 axios.post(..) 和 axios.get(..)，也可以使用统一形式的 API 发送请求和处理响应： 示例：发送用户名，请求用户的真实姓名。 下面代码中使用了 qs.stringify，因此需要在 标签中起始处添加 import qs from \"qs\"; 导入 qs 工具。本教程后面的代码如使用该工具，则同样需要添加。 this.$axios({ method: 'get', /* 指明请求方式，可以是 get 或 post */ url: '/user/realname', /* 指明后端 api 路径，由于在 main.js 已指定根路径，因此在此处只需写相对路由 */ data: qs.stringify({ /* 需要向后端传输的数据，此处使用 qs.stringify 将 json 数据序列化以发送后端 */ username: 'Zewan', }) }) .then(res => { /* res 是 response 的缩写 */ if (res.data.success) /* res.data 是后端返回的数据对象 */ this.realname = res.data.realname; else alert(\"获取失败！\"); }) .catch(err => { /* 请求若出现路由找不到等其它异常，则在终端输出错误信息 */ console.log(err); }) 当然，向后端发送请求的代码，是基于后端提供的 api 信息来编写的。比如对于上面这个例子，后端提供的 api 可以是如下格式： 条目 内容 根路径 http://123.12.123.12:8000 api路径 /user/realname 请求方式 GET 携带数据示例 { username: 'Zewan' } 返回数据示例 { success: true, realname: 'Zehuan Huang' } 或 { success: false } 关于前后端传输的数据格式(如上述携带数据和返回数据的示例)，可以由前后端人员一起商量确定。一个基本的网站需要较多的 api，而 api 格式的统一与否会影响前后端传输是否成功，比如后端返回了 realname，而前端中接收的是 real_name，就会导致网页无法正常显示姓名。 为了保证数据格式在前后端的统一，通常会在共享文档中维护各 api 的数据格式，并由后端提供成功或失败等多种情况的数据示例，以便前端正确地接收和处理数据。当然，后端也可以借助 Swagger 等工具，编写注释自动生成 API 在线文档(这就要看后端嫌不嫌麻烦了)。 并发请求 使用 axios 可以同时向两个或多个 api 发送请求，待请求都得到回复后再进行处理： methods: { getUserEmail: function() { return this.$axios({ method: 'get', url: '/user/getEmail', data: qs.stringify({ username: 'Zewan' }) }) }, getUserPasswd: function() { return this.$axios({ method: 'get', url: '/user/getPasswd', data: qs.stringify({ username: 'Zewan' }) }) }, getAllInfo: function() { this.$axios.all([getUserEmail(), getUserPasswd()]) .then(this.$axios.spread(function(email, passwd) { // email 和 passwd 分别表示两个 api 的 response，相当于上一个示例的 res // 在这里处理返回的数据 })) .catch(err => { console.log(err); }) } } 上述代码中，getUserEmail 和 getUserPasswd 两个函数定义了向两个 api 发送的 axios 请求，在 getAllInfo 中执行并发请求，并对返回数据进行处理。 本文仅介绍了 Axios 的基础用法，足以应对常见的开发任务。更多关于 Axios 的细节可以参考官方文档进行学习。 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part1/07-login-res.html":{"url":"post/part1/07-login-res.html","title":"Vue 开发实战二：登录请求","keywords":"","body":"Vue 开发实战二：登录请求Vuex 前端状态存储安装 Vuex创建 user 状态管理模式Vuex 存取命令Axios 发送登录请求安装 Axios全局引入登录请求路由拦截和返回路由拦截登录成功后返回原路由Vue 开发实战二：登录请求 在『Vue 开发实战一：登录页面』中，实现了较为简单的登录页面，还存在向后端发送登录请求和处理响应的坑，本文将填补该坑。 此次实践将实现： 用户点击登录按钮，前端向后端发送登录请求 前端从后端收到登录成功的信号后，使用 Vuex 保存用户信息 未登录用户访问个人中心，跳转至登录页面（全局路由钩子） 访问某页面被拦截至登录页面，登录成功后自动返回原访问页面 同时，代码将会同步至 Github 仓库。 Vuex 前端状态存储 用户登录和访问网站时，本地需要存储用户的一些基本信息，比如用户名、用户ID、身份认证 token 等。因此，在编写发送请求的代码前，先使用 Vuex 建立数据存储模式，以便在登录成功后保存用户信息。 Vuex 是专为 Vue.js 应用程序开发的状态管理模式，采用集中式存储管理应用所有组件的状态。简而言之，Vuex 可以帮助在前端存储用户数据，且在该网站的所有 Vue 组件、所有页面都能读写。 Vuex 没有作为单独一篇文章进行讲解，原因是其较为复杂，对于简单的单页应用可能有些大材小用。此处我仅用 Vuex 存储用户信息，用法套路固定，可以直接复制粘贴、学会怎么用即可。感兴趣可以参考官方文档进行学习。 安装 Vuex 创建项目时若已选中 Vuex，则已安装；否则需输入下列命令进行安装： npm install vuex --save 创建 user 状态管理模式 这部分代码想要彻底理解需要学习 Vuex 官方文档，建议初学者对下面代码有个大概了解即可，会用，后面再慢慢了解。 在 store 目录下创建 user.js，内容为： const key = 'user' const user = { /* 定义 user 数据对象和它的初始值 */ state() { return { user: null } }, /* 定义读取方法 getUser，从 localStorage 中读取 user 数据并转换成 JSON 格式 */ getters: { getUser: function (state) { if (!state.user) { state.user = JSON.parse(localStorage.getItem(key)) } return state.user } }, /* 定义更改 store 状态的事件 */ mutations: { /* 存数据，将 JSON 格式的数据转化为字符串形式存储到以 localStorage 中以 `user` 为键的值中 */ $_setStorage (state, value) { state.user = value localStorage.setItem(key, JSON.stringify(value)) }, /* 清空数据，将状态恢复初始值，并从 localStorage 中移除对象 */ $_removeStorage (state) { state.user = null localStorage.removeItem(key) } }, /* 定义调用 mutations 的方法，向上提供调用接口 */ actions: { /* 调用 _setStorage 方法存储数据 */ saveUserInfo({ commit }, data) { commit('$_setStorage', data) }, /* 调用 _removeStorage 方法清空数据 */ clearUserInfo({ commit }) { commit('$_removeStorage'); } } }; export default user 上述代码定义了 user 作为 Vuex 模块(Vuex Module)，该模块有自己的 state、getters、mutations、actions 四个属性。 在 store/index.js 文件中引入 user 模块： import Vue from 'vue' import Vuex from 'vuex' import user from \"./user\"; Vue.use(Vuex) export default new Vuex.Store({ state: { }, mutations: { }, actions: { /* 定义清空 localStorage 的方法 */ clear({ commit }) { commit(\"$_removeStorage\"); } }, modules: { user } }) Vuex 存取命令 上面步骤建立了 user 模块，这里介绍一些基础的用法，将在处理登录请求的返回信息中使用。 保存用户信息(常在登录时使用)： this.$store.dispatch('saveUserInfo', { user: { 'username': res.data.username, 'Authorization': res.data.Authorization, 'userId': res.data.user_id, } }); 清空本地存储数据(常在退出登录时使用)： this.$store.dispatch('clear'); 读取本地存储数据(在向后端发送请求或路由钩子时可使用)： const userInfo = user.getters.getUser(user.state()); /* userInfo 可用于判断用户登录信息，为 null 时表示用户未登录 */ if (userInfo) userInfo.user.userId /* 获取存储在本地的 userId，需与存储的数据结构对应 */ Axios 发送登录请求 Axios 是一个 HTTP 请求库，使用它来完成对后端的请求。 安装 Axios npm install axios --save 全局引入 全局引入，方便在各组件中可直接使用而无需重复引入。 在 main.js 中添加以下内容： import axios from 'axios' /* 引入 axios 并挂载到 Vue 实例上，在各 Vue 组件通过 this.$axios 进行使用 */ Vue.prototype.$axios = axios // 指定 axios 发送请求的目标后端地址的根路径 // 一般为后端服务器IP+端口；若有部署域名则可以是域名地址； // 此处假设在本地同时运行前后端，后端地址为 http://localhost:8000 axios.defaults.baseURL = 'http://localhost:8000'; 登录请求 在 Vue 开发实战一中，留下了 click_login 这个坑，下面将使用该函数实现登录请求。 假如后端提供的接口格式如下： 请求方式：POST Api相对路径：/user/login 请求数据示例： { \"username\": \"ZewanHuang\", \"password\": \"ZewanH123\" } 返回数据示例： // 成功登录的示例 { \"status_code\": 200, \"username\": \"ZewanHuang\", \"user_id\": \"1\", \"token\": \"ASDQW1231W3DWEEW12343\", }, // 用户名不存在的示例 { \"status_code\": 401 }, // 密码不正确的示例 { \"status_code\": 402 } 则 click_login 函数代码如下： 下面代码中使用了 qs.stringify，因此需要在 标签中起始处添加 import qs from \"qs\"; 导入 qs 工具。本教程后面的代码如使用该工具，则同样需要添加。 click_login() { this.$axios({ method: 'post', /* 指明请求方式，可以是 get 或 post */ url: '/user/login', /* 指明后端 api 路径，由于在 main.js 已指定根路径，因此在此处只需写相对路由 */ data: qs.stringify({ /* 需要向后端传输的数据，此处使用 qs.stringify 将 json 数据序列化以发送后端 */ username: this.username, password: this.password }) }) .then(res => { /* res 是 response 的缩写 */ switch (res.data.status_code) { case 200: window.alert(\"登录成功！\"); /* 将后端返回的 user 信息使用 vuex 存储起来 */ this.$store.dispatch('saveUserInfo', { user: { 'username': res.data.username, 'token': res.data.token, 'userId': res.data.user_id } }); break; case 401: window.alert(\"用户名不存在！\"); break; case 402: window.alert(\"密码错误！\"); break; } }) .catch(err => { console.log(err); /* 若出现异常则在终端输出相关信息 */ }) } 实现逻辑是，使用 axios 指定后端路由地址、携带数据发送请求，收到返回信息后，根据自定义的、代表不同意义的返回码，对各个情况做出不同的处理。 这样就实现了登录请求的发送和处理，当然，没有后端的支持，它还站不起来。 路由拦截和返回 路由拦截 很多网站都有这一功能，当未登录用户直接输入网址访问个人中心时，会自动跳转到登录页面。 先创建一个新页面，假设是个人中心页面，内容自由发挥(比如显示“个人中心”字样即可)，并在 router/index.js 中添加路由，设置为需要登录： 对于其它需要登录才能访问的路由，也添加如下的 meta 配置 { path: '/center', name: 'Center', component: () => import('../views/UserCenter'), meta: { requireAuth: true } } 继续在 router/index.js 中添加以下代码，判断访问页面若需要登录且当前未登录，则拦截至登录路由： [!WARNING|style:flat] 下面代码中 router.beforeEach 这一段需要在 const router = new VueRouter 代码段之后！ import user from \"@/store/user\"; router.beforeEach((to, from, next) => { // 通过 Vuex 获取用户登录信息 const userInfo = user.getters.getUser(user.state()); // 若用户未登录且访问的页面需要登录，则跳转至登录页面 if (!userInfo && to.meta.requireAuth) { next({ name: 'Login', }) } next() }) 登录成功后返回原路由 相比于登录成功后不管三七二十一返回首页，用户自然更希望被拦截后登录成功后，能自动返回原先访问的路由地址。 比如访问需要登录才能填写的问卷，当用户访问该问卷时，被拦截到登录页面，当用户登录成功后，正确的逻辑应该是自动返回到问卷页面。 实现逻辑：若前往的是登录路由，则保存当前路由到 localStorage；登录成功后，跳转到本地保存的路由。 在 router/index.js 中添加内容如下： router.beforeEach((to, from, next) => { // 通过 Vuex 获取用户登录信息 const userInfo = user.getters.getUser(user.state()); // 若前往的是登录路由，则保存当前路由到 preRoute 的键值对中，以便登录成功后跳转 if (to.path === '/login') { localStorage.setItem(\"preRoute\", router.currentRoute.fullPath); } // 若用户未登录且访问的页面需要登录，则跳转至登录页面 if (!userInfo && to.meta.requireAuth) { next({ name: 'Login', }) } next() }) 在登录组件的 login_click 函数中，添加登录成功后返回原路由的逻辑： /* 从 localStorage 中读取 preRoute 键对应的值 */ const history_pth = localStorage.getItem('preRoute'); /* 若保存的路由为空或为注册路由，则跳转首页；否则跳转前路由（setTimeout表示1000ms后执行） */ setTimeout(() => { if (history_pth == null || history_pth === '/register') { this.$router.push('/'); } else { this.$router.push({ path: history_pth }); } }, 1000); 至此，登录相关的功能需求已完成。当然，可能还存在一些细节待完善，比如系统获取到点击登录按钮的事件后，前端先检查用户名和密码是否为空，都不为空才向后端发送登录请求。（可自行完善） Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part1/08-elementUI.html":{"url":"post/part1/08-elementUI.html","title":"Vue 引入 ElementUI","keywords":"","body":"Vue 引入 ElementUInpm 安装 ElementUI全局引入如何使用Vue 引入 ElementUI 前面的文章介绍了 Vue 的基本用法，并使用纯 HTML+CSS+JS 实现了简易的登录页面。在日常开发中，纯手写 CSS 是比较考验前端的 CSS 能力的，而 UI 组件库提供了一些基本的组件单元，能帮助快速地搭建网站页面。 此处以 ElementUI 为例介绍如何使用。 UI 组件库一般都有官方文档，能很清晰地学会各种组件的用法 npm 安装 ElementUI npm i element-ui -S 全局引入 在 main.js 中添加以下内容： import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; Vue.use(ElementUI); 如何使用 在 ElementUI 官方文档中，以代码+效果图的形式展现了组件的用法，学习者可以根据需求合理地使用组件。 这里用 elementUI 实现一个简单的表单，涉及组件 Input 输入框、Button 按钮、Select 选择器、DateTimePicker 日期选择器。 简易表单 用户名：&emsp; 真实姓名： 性别：&emsp;&emsp; 出生日期： 自我介绍： 提交 export default { name: 'Form', data() { return { username: '', realname: '', sex: '', birthday: '', introduction: '', sex_options: [{value: '男'}, {value: '女'}] } }, methods: { submit() { alert(\"提交成功！\"); } } } .form-item { margin-top: 15px; } .font16 { font-size: 16px; } .el-input { position: relative; width: 350px; display: inline-block; } .sex .el-input { width: 100px; } .el-textarea { position: relative; width: 500px; display: inline-block; } 查看效果 ElementUI 官方文档详细地介绍了如何使用（含代码和效果图），因此这里不再过多赘述，学习者可以大致了解有哪些好用的组件，在开发时根据原型设计适当地选择和使用即可。 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part1/09-elementUI-login.html":{"url":"post/part1/09-elementUI-login.html","title":"Vue 开发实战三：重写登录","keywords":"","body":"Vue 开发实战三：重写登录ElementUI 安装和引入安装全局引入ElementUI 重写登录代码提示响应回车事件Scoped CSSVue 开发实战三：重写登录 本文将使用 elementUI 重写登录页面。 代码将同步至 Github 仓库。为避免覆盖原登录页面的代码，本文将新登录组件命名为 NewLogin.vue，路由指定为 /new_login。 ElementUI 安装和引入 安装 npm i element-ui -S 全局引入 在 main.js 中添加以下内容： import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; Vue.use(ElementUI); ElementUI 重写登录 页面所用组件含 Button 按钮、Input 输入框、Message 消息提示、Form 表单。相信结合官方指南，学习者很容易上手这些组件的使用，所以这里直接放出重写后的源代码。 登 录 登&nbsp;&nbsp;录 注册帐号 import qs from \"qs\"; export default { name: \"NewLogin\", data() { return { form: { username: '', password: '', } } }, methods: { login: function () { // 检查表单是否有填写内容 if (this.form.username === '' || this.form.password === '') { this.$message.warning(\"请输入用户名和密码！\"); return; } this.$axios({ method: 'post', /* 指明请求方式，可以是 get 或 post */ url: '/user/login', /* 指明后端 api 路径，由于在 main.js 已指定根路径，因此在此处只需写相对路由 */ data: qs.stringify({ /* 需要向后端传输的数据，此处使用 qs.stringify 将 json 数据序列化以发送后端 */ username: this.form.username, password: this.form.password }) }) .then(res => { /* res 是 response 的缩写 */ switch (res.data.status_code) { case 200: this.$message.success(\"登录成功！\"); /* 将后端返回的 user 信息使用 vuex 存储起来 */ this.$store.dispatch('saveUserInfo', { user: { 'username': res.data.username, 'token': res.data.token, 'userId': res.data.user_id } }); /* 从 localStorage 中读取 preRoute 键对应的值 */ const history_pth = localStorage.getItem('preRoute'); /* 若保存的路由为空或为注册路由，则跳转首页；否则跳转前路由（setTimeout表示1000ms后执行） */ setTimeout(() => { if (history_pth == null || history_pth === '/register') { this.$router.push('/'); } else { this.$router.push({ path: history_pth }); } }, 1000); break; case 401: this.$message.error(\"用户名不存在！\"); break; case 402: this.$message.error(\"密码错误！\"); break; } }) .catch(err => { console.log(err); /* 若出现异常则在终端输出相关信息 */ }) }, toRegister: function () { // 跳转注册的路由 this.$router.push('/register'); } } } #login { font-family: 'Noto Serif SC', serif; margin-top: 60px; } #login >>> .el-input__inner { font-family: 'Noto Serif SC', serif; } #login .bgbox { display: block; opacity: 1; z-index: -3; position: fixed; left: 0; top: 0; width: 100%; height: 100%; object-fit: cover; transition: opacity 1s,transform .25s,filter .25s; backface-visibility: hidden; } #login .logo { cursor: pointer; overflow: hidden; height: 150px; } #login .wrap { width: 300px; height: 315px; padding: 0 25px 0 25px; line-height: 40px; position: relative; display: inline-block; background-color: rgba(255, 255, 255, 0.85); border-radius: 20px; } #login .btn_login { margin-top: 25px; text-align: center; } #login .btn_login button{ line-height: 10px; font-family: 'Noto Serif SC', serif; width: 100%; height: 38px; } #login .suffix { font-size:14px; line-height:10px; color:#999; cursor: pointer; float:right; } 效果图如下： 代码提示 响应回车事件 在上面代码中，有这样一段代码： @keyup.enter.native=\"login\" 表示，用户在该输入框中使用键tade盘回车后，将触发 login 函数。 Scoped CSS 可以看到，在目前所写的组件中， 标签都有 scoped 属性，其作用是，保证它的 CSS 只作用于当前组件中的元素，防止不同组件（包含父组件与子组件之间）定义的类名相同的 CSS 类作用域混乱。 更详细的介绍可见 Scoped CSS - Vue Loader。 然而，使用 ElementUI 等 UI 组件库后，会遇到这样的情况：我们想在本页面文件中修改使用的 UI 组件的内置样式，但 UI 组件是定义于本文件外的，使用 scoped 属性后无法通过类名正常的指定和修改。当然，还是有办法修改其样式的，比如上面代码所使用的。 在上面代码的 CSS 部分，有这样的字段： #login >>> .el-input__inner {} >>> 是 CSS 中的深度作用选择器，顾名思义，它能使 scoped 样式中的一个选择器作用得更深，例如影响子组件。 .a >>> .b { /* ... */ } 将编译成： .a[data-v-f3f3eg9] .b { /* ... */ } 由此可见，通过深度作用选择器，我们可以在某个 Vue 文件的 scoped 样式中修改指定 UI 子组件的样式，且不会影响其它 Vue 文件中该 UI 子组件的原始样式。 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/part1/10-component.html":{"url":"post/part1/10-component.html","title":"Vue 组件","keywords":"","body":"Vue 组件Vue 组件 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/advanced/echart.html":{"url":"post/advanced/echart.html","title":"Echart 图表","keywords":"","body":"Echart 图表Echart 图表 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/else/npm-install.html":{"url":"post/else/npm-install.html","title":"npm install -save/-g 参数的区别","keywords":"","body":"npm install -save/-g 参数的区别特征npm install Xnpm install X --savenpm install X --save-devnpm install X -g-save 和 -save-dev 的区别使用原则npm install -save/-g 参数的区别 特征 npm install X 会把 X 包安装到 node_modules 目录中 不会修改 package.json 运行 npm install 命令时不会自动安装 X npm install X --save -save 和 --save 都可以，一道杠和两道杠效果一样 会把 X 包安装到 node_modules 目录中 会在 package.json 的 dependencies 属性下添加 X 执行 npm install 命令时，会自动安装 X 到 node_modules 目录中 执行 npm install –production 或者注明 NODE_ENV 变量值为 production 时，会自动安装 X 到 node_modules 目录中 npm install X --save-dev 会把 X 包安装到 node_modules 目录中 会在 package.json 的 devDependencies 属性下添加 X 执行 npm install 命令时，会自动安装 X 到 node_modules 目录中 执行 npm install –production 或者注明 NODE_ENV 变量值为 production 时，不会自动安装 X 到node_modules目录中 npm install X -g 安装模块到全局，不会在项目 node_modules 目录中保存模块包 不会将模块依赖写入 devDependencies 或 dependencies 节点 运行 npm install 初始化项目时不会自动安装模块 -save 和 -save-dev 的区别 devDependencies 中的包是在开发中用到的，发布后是找不到的；而 dependencies 中的包是开发和线上都需要用到的。 使用原则 项目框架或脚手架，比如 vue、vue-cli 等可以安装到全局，使用 -g； 对于项目依赖的包，仅开发时用到、发布部署后无需使用的，采用 -save-dev，否则使用 -save。 拿捏不好就用 -save Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "},"post/reference/reference.html":{"url":"post/reference/reference.html","title":"参考文献","keywords":"","body":"参考文献参考文献 菜鸟教程 Vue.js Axios 官方文档 Vue.js v2.x 官方文档 ElementUI 使用指南 Vue Loader 介绍 ZewanHuang/Questionnaire-Planet 问卷星球 npm install、npm install --save与npm install --save-dev、npm install -g区别 Copyright © blog.zewan.cc 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-25 03:21:11 "}}